/**
 * @file	test_callback.cpp
 * @brief	Test callback utility.
 * @author	Kacper Kowalski - kacper.kowalski@hum-systems.com
 */
#include "catch2/catch_test_macros.hpp"

#include "jungles/callback.hpp"

TEST_CASE("Callback can be assigned to a C function pointer", "[util][callback]")
{
    SECTION("Lambda can be assigned to a C function pointer")
    {
        static unsigned (*function)(char, float);

        function = jungles::assign_callback([](char, float) -> unsigned { return 5; });

        auto r{(*function)('c', 32.2)};

        REQUIRE(r == 5);
    }

    SECTION("Lambda that returns void can be assigned to the function pointer")
    {
        static void (*function)(char, float);

        function = jungles::assign_callback([](char, float) {});

        (*function)('c', 32.2);
    }

    SECTION("Lambda that returns void and takes void as parameter can be assigned to the function pointer")
    {
        static void (*function)();

        function = jungles::assign_callback([]() {});

        (*function)();
    }

    SECTION("Lambda that captures can be assigned to the function pointer")
    {
        static unsigned (*function)(char, float);

        bool is_captured_properly{false};

        function = jungles::assign_callback([&](char, float) -> unsigned {
            is_captured_properly = true;
            return 2;
        });

        auto was_flag_not_set_before_call{!is_captured_properly};

        (*function)('c', 32.2);

        REQUIRE(was_flag_not_set_before_call);
        REQUIRE(is_captured_properly);
    }

    SECTION("Lambda from within a class can be assigned to C function pointer")
    {
        static int (*function_pointer)(float, char);

        struct lambda_for_test1
        {
            explicit lambda_for_test1()
            {
                function_pointer = jungles::assign_callback([this](float f, char c) { return doer(f, c); });
            }

            int doer(float, char)
            {
                return 11;
            }
        };

        lambda_for_test1 t;

        auto r{(*function_pointer)(2.2, 'a')};

        REQUIRE(r == 11);
    }

    SECTION("Single callback is generated per one function pointer when the signature is the same")
    {
        // The problem which might arise is that the static function generated by the template might be
        // non unique for callbacks that have the same signature.
        // This test checks whether this is not the case.

        static void (*function_pointer1)(void);
        static void (*function_pointer2)(void);

        std::string str{"initial_value"};

        function_pointer1 = jungles::assign_callback([&]() { str = "first"; });
        function_pointer2 = jungles::assign_callback([&]() { str = "second"; });

        auto before_calls{str};

        (*function_pointer1)();
        auto after_first_call{str};
        (*function_pointer2)();
        auto after_second_call{str};
        (*function_pointer1)();
        auto after_third_call{str};

        REQUIRE(before_calls == "initial_value");
        REQUIRE(after_first_call == "first");
        REQUIRE(after_second_call == "second");
        REQUIRE(after_third_call == "first");
    }
}
